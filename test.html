<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>World Generator Test - Quick Iteration</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: #fff;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .controls {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #357abd;
    }

    select,
    input {
      padding: 6px 10px;
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }

    .canvas-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .canvas-container {
      background: #2a2a2a;
      padding: 10px;
      border-radius: 8px;
    }

    .canvas-container h3 {
      margin: 0 0 10px 0;
      color: #4a90e2;
      font-size: 14px;
    }

    canvas {
      border: 1px solid #444;
      width: 100%;
      height: auto;
      cursor: crosshair;
      image-rendering: pixelated;
    }

    .info-panel {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      height: fit-content;
    }

    .info-section {
      margin-bottom: 20px;
    }

    .info-section h3 {
      margin: 0 0 10px 0;
      color: #4a90e2;
      font-size: 16px;
    }

    pre {
      margin: 0;
      font-size: 12px;
      white-space: pre-wrap;
    }

    .progress {
      margin-top: 10px;
      display: none;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #333;
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #4a90e2;
      transition: width 0.3s;
    }

    .error {
      color: #ff6b6b;
      margin-top: 10px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      font-size: 12px;
    }

    .stat-label {
      color: #888;
    }

    .coordinates {
      background: #333;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üó∫Ô∏è World Generator Test Suite</h1>

    <div class="controls">
      <div class="control-group">
        <label>Size:</label>
        <select id="worldSize">
          <option value="tiny">Tiny (500x300)</option>
          <option value="small" selected>Small (1000x600)</option>
          <option value="medium">Medium (2000x1200)</option>
          <option value="large">Large (4000x2400)</option>
        </select>
      </div>

      <div class="control-group">
        <label>Seed:</label>
        <input type="text" id="seed" value="test123" style="width: 100px;">
        <button onclick="randomSeed()">üé≤ Random</button>
      </div>

      <div class="control-group">
        <button onclick="generateWorld()" id="generateBtn">üåç Generate World</button>
        <button onclick="analyzeWorld()" id="analyzeBtn" disabled>üìä Analyze</button>
        <button onclick="exportData()" id="exportBtn" disabled>üíæ Export</button>
      </div>

      <div class="control-group">
        <label>View Scale:</label>
        <input type="range" id="viewScale" min="0.1" max="1" step="0.1" value="0.5">
        <span id="scaleLabel">0.5x</span>
      </div>

      <div class="progress">
        <div class="progress-bar">
          <div class="progress-fill" id="progressBar"></div>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="canvas-grid">
        <div class="canvas-container">
          <h3>Elevation</h3>
          <canvas id="elevationCanvas"></canvas>
        </div>

        <div class="canvas-container">
          <h3>Biomes</h3>
          <canvas id="biomeCanvas"></canvas>
        </div>

        <div class="canvas-container">
          <h3>Water Bodies</h3>
          <canvas id="waterCanvas"></canvas>
        </div>

        <div class="canvas-container">
          <h3>Temperature</h3>
          <canvas id="temperatureCanvas"></canvas>
        </div>
      </div>

      <div class="info-panel">
        <div class="info-section">
          <h3>Generation Status</h3>
          <pre id="status">Ready to generate</pre>
        </div>

        <div class="info-section">
          <h3>World Statistics</h3>
          <div class="stats-grid" id="stats">
            <span class="stat-label">Land Coverage:</span><span>-</span>
            <span class="stat-label">Ocean Coverage:</span><span>-</span>
            <span class="stat-label">Avg Elevation:</span><span>-</span>
            <span class="stat-label">Max Elevation:</span><span>-</span>
            <span class="stat-label">Settlements:</span><span>-</span>
            <span class="stat-label">Biome Count:</span><span>-</span>
          </div>
        </div>

        <div class="info-section">
          <h3>Mouse Position</h3>
          <div class="coordinates" id="mouseInfo">
            Hover over map
          </div>
        </div>

        <div class="info-section">
          <h3>Performance</h3>
          <pre id="performance">-</pre>
        </div>
      </div>
    </div>

    <div class="error" id="errorMsg"></div>
  </div>

  <!-- Load the world generator -->
  <script src="gen.js"></script>

  <script>
    let worldBuilder = null;
    let currentScale = 0.5;

    // World size presets
    const WORLD_SIZES = {
      tiny: { width: 500, height: 300 },
      small: { width: 1000, height: 600 },
      medium: { width: 2000, height: 1200 },
      large: { width: 4000, height: 2400 }
    };

    // View scale control
    document.getElementById('viewScale').addEventListener('input', (e) => {
      currentScale = parseFloat(e.target.value);
      document.getElementById('scaleLabel').textContent = currentScale + 'x';
      if (worldBuilder) {
        renderAllMaps();
      }
    });

    function randomSeed() {
      document.getElementById('seed').value = 'seed' + Math.floor(Math.random() * 100000);
    }

    async function generateWorld() {
      const sizeKey = document.getElementById('worldSize').value;
      const size = WORLD_SIZES[sizeKey];
      const seed = document.getElementById('seed').value;

      // Update UI
      document.getElementById('generateBtn').disabled = true;
      document.getElementById('analyzeBtn').disabled = true;
      document.getElementById('exportBtn').disabled = true;
      document.getElementById('status').textContent = 'Initializing...';
      document.querySelector('.progress').style.display = 'block';
      document.getElementById('errorMsg').textContent = '';

      const startTime = performance.now();

      try {
        // Create world builder
        worldBuilder = new WorldBuilder({
          world: {
            width: size.width,
            height: size.height,
            seed: seed
          },
          settlements: {
            counts: {
              capital: 1,
              city: 2,
              town: 5,
              hamlet: 10
            }
          },
          enableDynamics: false
        });

        // Set progress callback
        worldBuilder.onProgress = (progress) => {
          document.getElementById('status').textContent = progress.stage;
          document.getElementById('progressBar').style.width = progress.percent + '%';
        };

        // Generate world
        await worldBuilder.generateWorld();

        const elapsed = performance.now() - startTime;
        document.getElementById('performance').textContent =
          `Generation time: ${elapsed.toFixed(0)}ms\nChunks generated: ${worldBuilder.worldGen.cache.memory.size}`;

        // Render all maps
        renderAllMaps();

        // Update stats
        updateStatistics();

        // Enable buttons
        document.getElementById('generateBtn').disabled = false;
        document.getElementById('analyzeBtn').disabled = false;
        document.getElementById('exportBtn').disabled = false;
        document.getElementById('status').textContent = 'Generation complete!';

      } catch (error) {
        console.error('Generation error:', error);
        document.getElementById('errorMsg').textContent = 'Error: ' + error.message;
        document.getElementById('generateBtn').disabled = false;
        document.getElementById('status').textContent = 'Generation failed';
      }

      document.querySelector('.progress').style.display = 'none';
    }

    function renderAllMaps() {
      renderMap('elevationCanvas', 'elevation');
      renderMap('biomeCanvas', 'biome');
      renderMap('waterCanvas', 'waterMask');
      renderMap('temperatureCanvas', 'temperature');
    }

    function renderMap(canvasId, layer) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      const width = Math.floor(worldBuilder.config.world.width * currentScale);
      const height = Math.floor(worldBuilder.config.world.height * currentScale);

      canvas.width = width;
      canvas.height = height;

      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const worldX = Math.floor(x / currentScale);
          const worldY = Math.floor(y / currentScale);

          const value = worldBuilder.worldGen.getCell(worldX, worldY, layer);
          const color = getColorForValue(layer, value);

          const idx = (y * width + x) * 4;
          data[idx] = color[0];
          data[idx + 1] = color[1];
          data[idx + 2] = color[2];
          data[idx + 3] = 255;
        }
      }

      ctx.putImageData(imageData, 0, 0);

      // Add mouse interaction
      canvas.onmousemove = (e) => handleMouseMove(e, canvas, layer);
    }

    function getColorForValue(layer, value) {
      if (value === null) return [0, 0, 0];

      switch (layer) {
        case 'elevation':
          if (value < -100) return [10, 30, 80];
          if (value < 0) return [30, 80, 150];
          if (value < 10) return [255, 240, 200];
          if (value < 50) return [120, 180, 120];
          if (value < 200) return [80, 140, 80];
          if (value < 500) return [140, 130, 90];
          if (value < 1000) return [120, 100, 80];
          if (value < 2000) return [140, 130, 120];
          return [240, 240, 240];

        case 'biome':
          const biomeColors = {
            0: [50, 100, 200], 1: [60, 120, 220], 2: [70, 140, 240],
            3: [240, 240, 255], 4: [200, 200, 180], 5: [50, 100, 50],
            6: [80, 140, 80], 7: [150, 200, 100], 8: [240, 220, 140],
            9: [200, 180, 100], 10: [40, 120, 40], 11: [180, 140, 100],
            12: [255, 240, 200]
          };
          return biomeColors[value] || [128, 128, 128];

        case 'waterMask':
          if (value === 0) return [150, 200, 100];
          if (value === 1) return [30, 80, 150];
          if (value === 2) return [50, 100, 200];
          return [70, 140, 240];

        case 'temperature':
          const t = (value + 20) / 60;
          return [255 * t, 128, 255 * (1 - t)];

        default:
          return [128, 128, 128];
      }
    }

    function handleMouseMove(e, canvas, layer) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / currentScale);
      const y = Math.floor((e.clientY - rect.top) / currentScale);

      if (x >= 0 && x < worldBuilder.config.world.width &&
        y >= 0 && y < worldBuilder.config.world.height) {

        const info = worldBuilder.getCellInfo(x, y);
        let text = `(${x}, ${y})\n`;

        switch (layer) {
          case 'elevation':
            text += `Elevation: ${info.terrain.elevation?.toFixed(1)}m\n`;
            text += `Slope: ${info.terrain.slope?.toFixed(3)}`;
            break;
          case 'biome':
            text += `Biome: ${info.climate.biome}\n`;
            text += `Vegetation: ${(info.ecology.vegetation * 100).toFixed(0)}%`;
            break;
          case 'waterMask':
            text += `Water: ${info.hydrology.waterType}\n`;
            text += `Flow: ${info.hydrology.flowAccumulation}`;
            break;
          case 'temperature':
            text += `Temp: ${info.climate.temperature?.toFixed(1)}¬∞C\n`;
            text += `Moisture: ${(info.climate.moisture * 100).toFixed(0)}%`;
            break;
        }

        document.getElementById('mouseInfo').textContent = text;
      }
    }

    function updateStatistics() {
      const samples = 1000;
      let landCount = 0;
      let totalElev = 0;
      let maxElev = -Infinity;
      const biomes = new Set();

      for (let i = 0; i < samples; i++) {
        const x = Math.floor(Math.random() * worldBuilder.config.world.width);
        const y = Math.floor(Math.random() * worldBuilder.config.world.height);

        const elev = worldBuilder.worldGen.getCell(x, y, 'elevation');
        if (elev > 0) {
          landCount++;
          totalElev += elev;
        }
        maxElev = Math.max(maxElev, elev);

        const biome = worldBuilder.worldGen.getCell(x, y, 'biome');
        if (biome !== null) biomes.add(biome);
      }

      const settlements = worldBuilder.worldGen.layers.get('settlements').getAllSettlements();

      const stats = document.getElementById('stats').children;
      stats[1].textContent = `${(landCount / samples * 100).toFixed(1)}%`;
      stats[3].textContent = `${((samples - landCount) / samples * 100).toFixed(1)}%`;
      stats[5].textContent = `${(totalElev / landCount).toFixed(0)}m`;
      stats[7].textContent = `${maxElev.toFixed(0)}m`;
      stats[9].textContent = settlements.length;
      stats[11].textContent = biomes.size;
    }

    async function analyzeWorld() {
      if (!worldBuilder) return;

      document.getElementById('status').textContent = 'Analyzing world...';

      // This would do more detailed analysis
      // For now, just update statistics
      updateStatistics();

      alert('Analysis complete! Check the statistics panel.');
    }

    function exportData() {
      if (!worldBuilder) return;

      const exportData = worldBuilder.exportWorld({
        layers: ['elevation', 'biome', 'waterMask'],
        includeVectors: true
      });

      const blob = new Blob([JSON.stringify(exportData, null, 2)],
        { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `world-${worldBuilder.config.world.seed}.json`;
      a.click();

      URL.revokeObjectURL(url);
    }
  </script>
</body>

</html>